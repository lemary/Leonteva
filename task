#include <iostream>

#include <vector>

#include <algorithm>

#include <cstring>

const int64_t NSize = 2005;
const int64_t MSize = 20005;
const int64_t kInf = 1e10;
const long double kEps = 1e-7;

struct Edge {
  int64_t x;
  int64_t y;
};

std::vector < Edge > edges;
std::vector < uint8_t > vis, cut;
std::vector < long double > f;
std::vector < int64_t > vtx;
int64_t ne[MSize], tot;
int64_t S, T, now, N, M;
int64_t d[NSize], L[NSize], q[NSize], pre[NSize];
long double Mincut;

void Update(size_t u, size_t v, long double fl) {
  ++tot;
  f[tot] = fl;
  vtx[tot] = v;
  ne[tot] = L[u];
  L[u] = tot;
  ++tot;
  f[tot] = 0;
  vtx[tot] = u;
  ne[tot] = L[v];
  L[v] = tot;
}

long double MinFlow() {
  long double fl = kInf;
  for (int64_t i = T; i != S; i = vtx[pre[i] ^ 1]) {
    fl = std::min(fl, f[pre[i]]);
  }
  return fl;
}

void UpdateMinFlow(long double flow) {
  for (size_t i = T; i != S; i = vtx[pre[i] ^ 1]) {
    f[pre[i] ^ 1] += flow;
    f[pre[i]] -= flow;
    if (f[pre[i]] < kEps) {
      now = vtx[pre[i] ^ 1];
    }
  }
}

inline void Flow() {
  long double flow = MinFlow();
  Mincut += flow;
  UpdateMinFlow(flow);
}

void Dinic(size_t u) {
  if (T == u) {
    Flow();
    return;
  }
  int64_t p = L[u];
  while (p != 0) {
    if (f[p] > kEps && 1 + d[u] == d[vtx[p]]) {
      pre[vtx[p]] = p;
      Dinic(vtx[p]);
      if (d[now] < d[u]) {
        return;
      }
      now = T;
    }
    p = ne[p];
  }
  d[u] = -1;
}

bool ExtendCalc(int64_t & t, int64_t & u) {
  int64_t p = L[u];
  while (p != 0) {
    if (kEps < f[p] && (1 << 30) == d[vtx[p]]) {
      d[vtx[p]] = 1 + d[u];
      if (T == vtx[p]) {
        return true;
      }
      ++t;
      q[t] = vtx[p];
    }
    p = ne[p];
  }
  return false;
}

bool Extend() {
  q[1] = S;
  int64_t h = 1;
  int64_t t = 1;
  for (size_t i = 0; i < NSize; ++i) {
    d[i] = (i == S ? 0 : 1 << 30);
  }
  while (h <= t) {
    if (ExtendCalc(t, q[h])) {
      return true;
    }
    ++h;
  }
  return false;
}

bool MinCutCalc() {
  Mincut = 0;
  while (Extend()) {
    Dinic(S);
  }
  return Mincut < M;
}

bool BinSearchEl(long double g) {
  tot = 1;
  memset(L, 0, sizeof(L));
  for (size_t i = 0; i < N; ++i) {
    Update(S, i + 1, g);
  }
  for (size_t i = 0; i < M; ++i) {
    Update(edges[i].x, N + i + 1, kInf);
    Update(edges[i].y, N + i + 1, kInf);
    Update(N + i + 1, T, 1);
  }
  return MinCutCalc();
}

void FindCutCalc(int64_t u, int64_t & t) {
  int64_t p = L[u];
  while (p != 0) {
    if (kEps < f[p] && vis[vtx[p]] == 0) {
      ++t;
      q[t] = vtx[p];
      vis[vtx[p]] = 1;
    }
    p = ne[p];
  }
}

void FindCutSecond() {
  int64_t p;
  for (size_t u = 1; u <= T; ++u) {
    p = L[u];
    while (p != 0) {
      if (p % 2 == 0 && vis[u] != vis[vtx[p]]) {
        cut[p] = 1;
      }
      p = ne[p];
    }
  }
}

void FindCut() {
  q[1] = S;
  vis[S] = 1;
  int64_t h = 1;
  int64_t u = q[h];
  int64_t t = 1;
  while (t >= h) {
    FindCutCalc(u, t);
    ++h;
    u = q[h];
  }
  FindCutSecond();
}

void BinSearch(size_t Time) {
  long double l = 0.;
  long double r = M;
  long double mid;
  for (size_t i = 0; i < Time; ++i) {
    mid = (l + r) / 2.;
    (BinSearchEl(mid) ? l : r) = mid;
  }
  BinSearchEl(l);
}

void PrintAns(const std::vector < size_t > & ans) {
  std::cout << ans.size() << std::endl;
  for (auto it: ans) {
    std::cout << it << std::endl;
  }
}

std::vector < size_t > GetAns() {
  int64_t p = L[S];
  std::vector < size_t > ans;
  while (p != 0) {
    if (cut[p] != 0) {
      ans.push_back(vtx[p]);
    }
    p = ne[p];
  }
  std::reverse(ans.begin(), ans.end());
  return ans;
}

int main() {
  std::cin >> N >> M;
  if (M == 0 || N == 1) {
    std::cout << 1 << std::endl;
    std::cout << 1 << std::endl;
    return 0;
  }
  edges.resize(M + 1);
  for (size_t i = 0; i < M; ++i) {
    std::cin >> edges[i].x >> edges[i].y;
  }
  S = N + M + 1;
  T = N + M + 2;
  vis.resize(NSize);
  cut.resize(MSize);
  f.resize(MSize);
  vtx.resize(MSize);
  BinSearch(24);
  FindCut();
  PrintAns(GetAns());
  return 0;
}
